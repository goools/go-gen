package enum_generator

import (
	"fmt"
	"github.com/dave/jennifer/jen"
	"github.com/goools/go-gen/generate"
	"github.com/goools/go-gen/packagex"
	"github.com/sirupsen/logrus"
	"go/types"
	"os"
	"path/filepath"
)

type EnumOption struct {
	ConstValue int64  `json:"constValue"`
	Value      string `json:"value"`
	Doc        string `json:"doc"`
}

func NewEnum(pkgPath, enumName string, options []EnumOption) *Enum {
	return &Enum{
		PkgPath: pkgPath,
		Name:    enumName,
		Options: options,
	}
}

type Enum struct {
	PkgPath string
	Name    string
	Options []EnumOption
}

func (enum *Enum) writeString() jen.Code {
	funcName := "String"
	this := "e"
	var cases []jen.Code
	logrus.Infof("enum: %#v", enum)
	for i := range enum.Options {
		cases = append(cases, jen.Case(jen.Id(fmt.Sprintf("%s%s", enum.Name, enum.Options[i].Value))).Block(
			jen.Return(jen.Lit(enum.Options[i].Value)),
		))
	}
	return jen.Func().Params(
		jen.Id(this).Id(fmt.Sprintf("*%s", enum.Name)),
	).Id(funcName).Params().String().Block(
		jen.Switch(jen.Id(fmt.Sprintf("*%s", this))).Block(cases...),
		jen.Return(jen.Lit("UNKNOWN")),
	)
}

func NewEnumGenerator(pkg *packagex.Package) generate.Generator {
	return &EnumGenerator{
		pkg:   pkg,
		enums: map[*types.TypeName]*Enum{},
	}
}

type EnumGenerator struct {
	pkg   *packagex.Package
	enums map[*types.TypeName]*Enum
}

func (gen *EnumGenerator) Scan(enumNames ...string) {
	logrus.Debugf("enum_generator names: %v", enumNames)
	scanner := EnumScanner{
		pkg: gen.pkg,
	}
	for _, enumName := range enumNames {
		typeName := gen.pkg.TypeName(enumName)
		if typeName == nil {
			logrus.Fatalf("Not found enum_generator name %s", enumName)
		}
		gen.enums[typeName] = scanner.Scan(typeName)
	}
}

func (gen *EnumGenerator) WriteToFile() {
	packageFilePath, err := os.Getwd()
	if err != nil {
		logrus.Fatalf("get pwd have an err: %v", err)
	}
	for _, enum := range gen.enums {
		gen.writeToFile(packageFilePath, enum)
	}
}

func (gen *EnumGenerator) writeToFile(packageFilePath string, enum *Enum) {

	enumFileName := fmt.Sprintf("%s_generate.go", generate.ToSnakeCase(enum.Name))
	enumFilePath := filepath.Join(packageFilePath, enumFileName)
	logrus.Infof("begin generate enum: %s, package path: %s, file path: %s",
		enum.Name, enum.PkgPath, enumFilePath)
	generateFile := jen.NewFilePath(enum.PkgPath)
	generateFile.HeaderComment(WriteDoNotEdit())
	generateFile.Add(enum.writeString())
	//logrus.Infof("generateFile: %#v", generateFile)
	err := generateFile.Save(enumFilePath)
	if err != nil {
		logrus.Fatalf("save enum code to file have an err: %v, enum: %s, file: %s", err, enum.Name, enumFilePath)
	}
}

func WriteDoNotEdit() string {
	return "Code generated by go-gen DO NOT EDIT."
}
